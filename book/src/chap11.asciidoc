[[chap11]]
== Dicionários

Este capítulo apresenta outra estrutura de dados embutida chamada de dicionário.

=== Um Dicionário é um Mapeamento

Um _dicionário_ é como um array, mas mais geral. Em um array, os indíces tem que ser inteiros; em um dicionário eles podem ser (quase) de qualquer tipo.
(((dicionário)))

Um dicionário contém uma coleção de indíces, que são chamados de _chaves_, e uma coleção de valores. Cada chave é associada a um único valor. A associação de uma chave e um valor é chamada de _par chave-valor_ ou, as vezes, um item.
(((chave)))(((valor)))(((par chave-valor)))(((item)))

Em linguagem matemática, um dicionário representa um _mapeamento_ de chave para valores, então você também pode dizer que cada chave “é mapeado” para um valor. Como um exemplo, iremos construir um dicionário que mapeia palavras em Português para palavras em Espanhol, então as chaves e os valores são todos strings.
(((mapeamento)))

A função +Dict+ cria um novo dicionário sem items. Como +Dict+ é um nome de uma função embutida, devemos evitar usar ele como um nome de variável.
(((Dict)))((("tipo", "Base", "Dict", see="Dict")))

[source,@julia-repl-test chap11]
----
julia> por2sp = Dict()
Dict{Any,Any} with 0 entries
----

O tipo de dicionário é cercado por chaves: as chaves são do tipo +Any+ e os valores também são do tipo +Any+.
(((chaves)))((("{}", see="chaves")))(((Any)))((("tipo", "Base", "Any", see="Any")))

O dicionário está vazio. Para adicionar items no dicionário, podemos usar os colchetes:
(((colchetes)))

[source,@julia-repl-test chap11]
----
julia> por2sp["um"] = "uno";

----

Essa linha cria um item que mapeia a chave "um" para o valor "uno". Se nós imprimirmos o dicionário novamente, nós vemos o par chave-valor com a flecha +pass:[=&gt;]+ entre a chave e o valor:
(((pass:[=&gt;])))

[source,@julia-repl-test chap11]
----
julia> por2sp
Dict{Any,Any} with 1 entry:
  "um" => "uno"
----

Esse formato de resultado também é um formato de entrada. Por exemplo, você pode criar um novo dicionário com três itens:

[source,@julia-repl-test chap11]
----
julia> por2sp = Dict("um" => "uno", "dois" => "dos", "três" => "tres")
Dict{String,String} with 3 entries:
  "dois"   => "dos"
  "um"   => "uno"
  "três" => "tres"
----

Todas as chaves e os valores iniciais são strings, então um +Dict{String, String}+ é criado.

[WARNING]
====
A ordem do par chave-valor pode não ser a mesma. Se você digitar o mesmo exemplo no seu computador, você pode obter um resultado diferente. Em geral, a ordem dos itens em um dicionário é imprevisível.
====

Mas isso não é um problema pois os elementos de um dicionário nunca são indexados com indíces inteiros. Ao invés disso, nós usamos as chaves para consultar os valores correspondentes:

[source,@julia-repl-test chap11]
----
julia> por2sp["dois"]
"dos"
----

A chave "dois" sempre é mapeada par ao valor "dos", então a ordem dos itens não importa.

Se a chave não está no dicionário, nós recebemos uma exceção:
(((KeyError)))((("error", "Base", "KeyError", see="KeyError")))

[source,@julia-repl-test chap11]
----
julia> por2sp["quatro"]
ERROR: KeyError: key "four" not found
----

A função +length+ funciona em dicionários; ela retorna o número de pares chave-valor:
(((length)))

[source,@julia-repl-test chap11]
----
julia> length(por2sp)
3
----

A função +keys+ retorna uma lista com as chaves do dicionário:
(((keys)))((("função", "Base", "keys", see="keys")))

[source,@julia-repl-test chap11]
----
julia> ks = keys(por2sp);

julia> print(ks)
["dois", "um", "três"]
----

Agora você pode usar o operador +∈+ para verificar se algo aparece como uma _chave_ no dicionário:
(((in)))

[source,@julia-repl-test chap11]
----
julia> "um" ∈ ks
true
julia> "uno" ∈ ks
false
----

Para verificar se algo aparece como um valor em um dicionário, você pode usar a função +values+, que retorna uma coleção de valores, e em seguida usar o operador +∈+:
(((valores)))((("função", "Base", "valores", see="valores")))

[source,@julia-repl-test chap11]
----
julia> vs = values(por2sp);

julia> "uno" ∈ vs
true
----

O operador +∈+ utiliza algoritmos diferentes para arrays e dicionários. Para arrays, ele busca os elementos do array em ordem, como em <<searching>>. À medida que o array fica maior, o tempo de busca cresce em proporção direta.

Para dicionários, o Julia usa um algoritmo chamado de _tabela hash_ que possui uma propriedade expecional: o operador +∈+ leva aproximadamente o mesmo não importa quantos itens o dicionário possui.
(((tabela hash)))

[[dictionary_collection_counters]]
=== Dicionários como uma Coleção de Contadores

Suponha que é dado à você uma string e você gostaria de contar quantas vezes cada letra aparece. Existem muitas maneiras de fazer isso:

* Você poderia criar 26 variáveis, um para cada letra do alfabeto. Em seguida você poderia percorrer a string, e para cada caractere, incrementar o contador correspondente, provávelmente usando um condicional encadeado.

* Você poderia criar um array com 26 elementos. Em seguida você poderia converter cada caractere para um número (usando a função embutida +Int+), usar o número como um indíce para o array, e incrementar o contador adequado.

* Você poderia criar um dicionário com caracteres como chaves e contadores como seus valores correspondentes. A primeira vez que você vê um caractere, você adicionaria um item no dicionário. Após isso você incrementaria o valor de um item existente.

Cada uma dessas opções efetua o mesmo cálculo, mas cada uma delas implementa este cálculo de maneiras diferentes.

Uma _implementação_ é uma maneira de efetuar um cálculo; algumas implementações são melhores que outras. Por exemplo, uma vantagem da implementação do dicionário é que nós não temos que saber antecipadamente quais letras aparecem na string, e nós temos que somente criar espaço para as letras que aparecem.
(((implementação)))

O código pode parecer com algo como:

[source,@julia-setup chap11]
----
function histograma(s)
    d = Dict()
    for c in s
        if c ∉ keys(d)
            d[c] = 1
        else
            d[c] += 1
        end
    end
    d
end
----

O nome da função é +histograma+, que é um termo estátistico para uma coleção de contadores (ou frequências).
(((histograma)))((("função", "definido pelo programador", "histograma", see="histograma")))

A primeira linha da função cria um dicionário vazio. O loop +for+ percorre a string. Toda vez que o loop é percorrido, se o caractere +c+ não está no dicionário, nós criamos um novo item com a chave +c+ e o valor inicial +1+ (já que nós vimos esta letra uma vez). Se +c+ já está no dicionário, nós incrementamos +d[c]+.

Funciona da seguinte forma:

[source,@julia-repl-test chap11]
----
julia> h = histograma("brontosaurus")
Dict{Any,Any} with 8 entries:
  'n' => 1
  's' => 2
  'a' => 1
  'r' => 2
  't' => 1
  'o' => 2
  'u' => 2
  'b' => 1
----

O histograma indica que as letras +'a'+ e +'b'+ aparecem uma vez; +'o'+ aparece duas, e assim em diante.

Dicionários possuem uma função chamada +get+ que recebe uma chave e uma valor padrão. Se a chave aparece no dicionário, +get+ retorna o valor correspondente; caso contrário ela retorna o valor padrão. Por exemplo:
(((get)))((("função", "Base", "get", see="get")))

[source,@julia-repl-test chap11]
----
julia> h = histograma("a")
Dict{Any,Any} with 1 entry:
  'a' => 1
julia> get(h, 'a', 0)
1
julia> get(h, 'b', 0)
0
----

===== Exercício 11-1

Use +get+ para escrever +histograma+ de uma maneira mais concisa. Você deve ser capaz de eliminar a declaração +if+.


=== Dando Laços e Dicionários

Você pode percorrer as chaves de um dicionário em uma declaração +for+. Por exemplo, +imprimehist+ exibe cada chave e o seu valor correspondente:
(((imprimehist)))((("função", "definido pelo programador", "imprimehist", see="imprimehist")))

[source,@julia-setup chap11]
----
function imprimehist(h)
    for c in keys(h)
        println(c, " ", h[c])
    end
end
----

Aqui está o resultado:

[source,@julia-repl-test chap11]
----
julia> h = histograma("papagaio");

julia> imprimehist(h)
a 3
g 1
p 2
i 1
o 1
----

Novamente, as chaves não estão em nenhuma ordem específica. Para percorrer as chaves em ordem, você pode combinar +sort+ e +collect+:
(((sort)))(((collect)))

[source,@julia-repl-test chap11]
----
julia> for c in sort(collect(keys(h)))
           println(c, " ", h[c])
       end
a 3
g 1
i 1
o 1
p 2
----


=== Reverse Lookup

Given a dictionary +d+ and a key +k+, it is easy to find the corresponding value +v = d[k]+. This operation is called a _lookup_.
(((lookup)))

But what if you have +v+ and you want to find +k+? You have two problems: first, there might be more than one key that maps to the value +v+. Depending on the application, you might be able to pick one, or you might have to make an array that contains all of them. Second, there is no simple syntax to do a _reverse lookup_; you have to search.
(((reverse lookup)))

Here is a function that takes a value and returns the first key that maps to that value:

[source,@julia-setup chap11]
----
function reverselookup(d, v)
    for k in keys(d)
        if d[k] == v
            return k
        end
    end
    error("LookupError")
end
----

This function is yet another example of the search pattern, but it uses a function we haven’t seen before, +error+. The +error+ function is used to produce an +ErrorException+ that interrupts the normal flow of control. In this case it has the message +"LookupError"+, indicating that a key does not exist.
(((error)))((("function", "Base", "error", see="error")))

If we get to the end of the loop, that means +v+ doesn’t appear in the dictionary as a value, so we throw an exception.

Here is an example of a successful reverse lookup:

[source,@julia-repl-test chap11]
----
julia> h = histograma("parrot");

julia> key = reverselookup(h, 2)
'r': ASCII/Unicode U+0072 (category Ll: Letter, lowercase)
----

And an unsuccessful one:

[source,@julia-repl-test chap11]
----
julia> key = reverselookup(h, 3)
ERROR: LookupError
----

The effect when you generate an exception is the same as when Julia throws one: it prints a stacktrace and an error message.

Julia provides an optimized way to do a reverse lookup: +findall(isequal(3), h)+.
(((findall)))((("function", "Base", "findall", see="findall")))(((isequal)))((("function", "Base", "isequal", see="isequal")))

[WARNING]
====
A reverse lookup is much slower than a forward lookup; if you have to do it often, or if the dictionary gets big, the performance of your program will suffer.
====


=== Dictionaries and Arrays

Arrays can appear as values in a dictionary. For example, if you are given a dictionary that maps from letters to frequencies, you might want to invert it; that is, create a dictionary that maps from frequencies to letters. Since there might be several letters with the same frequency, each value in the inverted dictionary should be an array of letters.

Here is a function that inverts a dictionary:
(((invertdict)))((("function", "programmer-defined", "invertdict", see="invertdict")))

[source,@julia-setup chap11]
----
function invertdict(d)
    inverse = Dict()
    for key in keys(d)
        val = d[key]
        if val ∉ keys(inverse)
            inverse[val] = [key]
        else
            push!(inverse[val], key)
        end
    end
    inverse
end
----

Each time through the loop, +key+ gets a key from +d+ and +val+ gets the corresponding value. If +val+ is not in +inverse+, that means we haven’t seen it before, so we create a new item and initialize it with a _singleton_ (an array that contains a single element). Otherwise we have seen this value before, so we append the corresponding key to the array.
(((singleton)))

Here is an example:

[source,@julia-repl-test chap11]
----
julia> hist = histograma("parrot");

julia> inverse = invertdict(hist)
Dict{Any,Any} with 2 entries:
  2 => ['r']
  1 => ['a', 'p', 'o', 't']
----

[[fig11-1]]
.State diagram
image::images/fig111.svg[]


<<fig11-1>> is a state diagram showing +hist+ and +inverse+. A dictionary is represented as a box with the key-value pairs inside. If the values are integers, floats or strings, I draw them inside the box, but I usually draw arrays outside the box, just to keep the diagram simple.
(((state diagram)))

[NOTE]
====
I mentioned earlier that a dictionary is implemented using a hash table and that means that the keys have to be _hashable_.
(((hashable)))

A _hash_ is a function that takes a value (of any kind) and returns an integer. Dictionaries use these integers, called hash values, to store and look up key-value pairs.
(((hash)))
====

[[memos]]
=== Memos

If you played with the +fibonacci+ function from <<one_more_example>>, you might have noticed that the bigger the argument you provide, the longer the function takes to run. Furthermore, the run time increases quickly.
(((fibonnaci)))

To understand why, consider <<fig11-2>>, which shows the _call graph_ for +fibonacci+ with +n = 4+:
(((call graph)))((("diagram", "call graph", see="call graph")))

[[fig11-2]]
.Call graph
image::images/fig112.svg[]


A call graph shows a set of function frames, with lines connecting each frame to the frames of the functions it calls. At the top of the graph, +fibonacci+ with +n = 4+ calls +fibonacci+ with  +n = 3+ and +n = 2+. In turn, +fibonacci+ with +n = 3+ calls +fibonacci+ with +n = 2+ and +n = 1+. And so on.

Count how many times +fibonacci(0)+ and +fibonacci(1)+ are called. This is an inefficient solution to the problem, and it gets worse as the argument gets bigger.

One solution is to keep track of values that have already been computed by storing them in a dictionary. A previously computed value that is stored for later use is called a _memo_. Here is a “memoized” version of fibonacci:
(((memo)))

[source,@julia-setup]
----
known = Dict(0=>0, 1=>1)

function fibonacci(n)
    if n ∈ keys(known)
        return known[n]
    end
    res = fibonacci(n-1) + fibonacci(n-2)
    known[n] = res
    res
end
----

+known+ is a dictionary that keeps track of the Fibonacci numbers we already know. It starts with two items: +0+ maps to +0+ and +1+ maps to +1+.

Whenever +fibonacci+ is called, it checks +known+. If the result is already there, it can return immediately. Otherwise it has to compute the new value, add it to the dictionary, and return it.

If you run this version of +fibonacci+ and compare it with the original, you will find that it is much faster.

[[global_variables]]
=== Global Variables

In the previous example, known is created outside the function, so it belongs to the special frame called +Main+. Variables in +Main+ are sometimes called _global_ because they can be accessed from any function. Unlike local variables, which disappear when their function ends, global variables persist from one function call to the next.
(((global)))((("keyword", "global", see="global")))(((global variable)))

It is common to use global variables for _flags_; that is, boolean variables that indicate (“flag”) whether a condition is true. For example, some programs use a flag named +verbose+ to control the level of detail in the output:
(((flag)))

[source,@julia-setup]
----
verbose = true

function example1()
    if verbose
        println("Running example1")
    end
end
----

If you try to reassign a global variable, you might be surprised. The following example is supposed to keep track of whether the function has been called:

[source,@julia-setup]
----
been_called = false

function example2()
    been_called = true         # WRONG
end
----

But if you run it you will see that the value of +been_called+ doesn’t change. The problem is that +example2+ creates a new local variable named +been_called+. The local variable goes away when the function ends, and has no effect on the global variable.

To reassign a global variable inside a function you have to _declare_ the variable global before you use it:
(((declaration)))(((reassignment)))

[source,@julia-setup]
----
been_called = false

function example2()
    global been_called
    been_called = true
end
----

The _global statement_ tells the interpreter something like, “In this function, when I say +been_called+, I mean the global variable; don’t create a local one.”
(((global statement)))((("statement", "global", see="global statement")))

Here’s an example that tries to update a global variable:

[source,@julia-setup chap11]
----
count = 0

function example3()
    count = count + 1          # WRONG
end
----

If you run it you get:
(((UndefVarError)))

[source,@julia-repl-test chap11]
----
julia> example3()
ERROR: UndefVarError: count not defined
----

Julia assumes that +count+ is local, and under that assumption you are reading it before writing it. The solution, again, is to declare +count+ global.

[source,@julia-setup]
----
count = 0

function example3()
    global count
    count += 1
end
----

If a global variable refers to a mutable value, you can modify the value without declaring the variable global:

[source,@julia-setup]
----
known = Dict(0=>0, 1=>1)

function example4()
    known[2] = 1
end
----

So you can add, remove and replace elements of a global array or dictionary, but if you want to reassign the variable, you have to declare it global:

[source,@julia-setup]
----
known = Dict(0=>0, 1=>1)

function example5()
    global known
    known = Dict()
end
----

For performance reasons, you should declare a global variable constant. You can no longer reassign the variable but if it refers to a mutable value, you can modify the value.
(((const)))((("keyword", "const", see="const")))(((constant global variable)))

[source,@julia-setup]
----
const known = Dict(0=>0, 1=>1)

function example4()
    known[2] = 1
end
----

[WARNING]
====
Global variables can be useful, but if you have a lot of them, and you modify them frequently, they can make programs hard to debug and perform badly.
====

=== Debugging

As you work with bigger datasets it can become unwieldy to debug by printing and checking the output by hand. Here are some suggestions for debugging large datasets:
(((debugging)))

* Scale down the input:
+
If possible, reduce the size of the dataset. For example if the program reads a text file, start with just the first 10 lines, or with the smallest example you can find which errors. You should not edit the files themselves, but rather modify the program so it reads only the first latexmath:[\(n\)] lines.
(((scale down)))
+
If there is an error, you can reduce latexmath:[\(n\)] to the smallest value that manifests the error, and then increase it gradually as you find and correct errors.

* Check summaries and types:
+
Instead of printing and checking the entire dataset, consider printing summaries of the data: for example, the number of items in a dictionary or the total of an array of numbers.
(((check)))
+
A common cause of runtime errors is a value that is not the right type. For debugging this kind of error, it is often enough to print the type of a value.

* Write self-checks:
+
Sometimes you can write code to check for errors automatically. For example, if you are computing the average of an array of numbers, you could check that the result is not greater than the largest element in the array or less than the smallest. This is called a “sanity check”.
(((self-check)))(((sanity check)))
+
Another kind of check compares the results of two different computations to see if they are consistent. This is called a “consistency check”.
(((consistency check)))

* Format the output:
+
Formatting debugging output can make it easier to spot an error. We saw an example in <<deb06>>.
(((formatting)))
+
Again, time you spend building scaffolding can reduce the time you spend debugging.
(((scaffolding)))(((debugging)))


=== Glossary

mapping::
A relationship in which each element of one set corresponds to an element of another set.
(((mapping)))

dictionary::
A mapping from keys to their corresponding values.
(((dictionary)))

key-value pair::
The representation of the mapping from a key to a value.
(((key-value pair)))

item::
In a dictionary, another name for a key-value pair.
(((item)))

key::
An object that appears in a dictionary as the first part of a key-value pair.
(((key)))

value::
An object that appears in a dictionary as the second part of a key-value pair. This is more specific than our previous use of the word “value”.
(((value)))

implementation::
A way of performing a computation.
(((implementation)))

hash table::
The algorithm used to implement Julia dictionaries.
(((hash table)))

hash function::
A function used by a hash table to compute the location for a key.
(((hash function)))

hashable::
A type that has a hash function.
(((hashable)))

lookup::
A dictionary operation that takes a key and finds the corresponding value.
(((lookup)))

reverse lookup::
A dictionary operation that takes a value and finds one or more keys that map to it.
(((reverse lookup)))

singleton::
An array (or other sequence) with a single element.
(((singleton)))

call graph::
A diagram that shows every frame created during the execution of a program, with an arrow from each caller to each callee.
(((call graph)))

memo::
A computed value stored to avoid unnecessary future computation.
(((memo)))

global variable::
A variable defined outside a function. Global variables can be accessed from any function.
(((global variable)))

global statement::
A statement that declares a variable name global.
(((global statement)))

flag::
A boolean variable used to indicate whether a condition is true.
(((flag)))

declaration::
A statement like +global+ that tells the interpreter something about a variable.
(((declaration)))

constant global variable::
A global variable that can not be reassigned.
(((constant global variable)))


=== Exercises

[[ex11-1]]
===== Exercício 11-2

Write a function that reads the words in _words.txt_ and stores them as keys in a dictionary. It doesn’t matter what the values are. Then you can use the +∈+ operator as a fast way to check whether a string is in the dictionary.
(((in)))

If you did <<ex10-10>>, you can compare the speed of this implementation with the array +∈+ operator and the bisection search.

[[ex11-2]]
===== Exercício 11-3

Read the documentation of the dictionary function +get!+ and use it to write a more concise version of +invertdict+.
(((get!)))((("function", "Base", "get!", see="get!")))

[[ex11-3]]
===== Exercício 11-4

Memoize the Ackermann function from <<ex06-2>> and see if memoization makes it possible to evaluate the function with bigger arguments.
(((memo)))(((Ackermann function)))

[[ex11-4]]
===== Exercício 11-5

If you did <<ex10-7>>, you already have a function named +hasduplicates+ that takes an array as a parameter and returns +true+ if there is any object that appears more than once in the array.
(((hasduplicates)))

Use a dictionary to write a faster, simpler version of +hasduplicates+.

[[ex11-5]]
===== Exercício 11-6

Two words are “rotate pairs” if you can rotate one of them and get the other (see +rotateword+ in <<ex08-5>>).
(((rotateword)))

Write a program that reads a word array and finds all the rotate pairs.

[[ex11-6]]
===== Exercício 11-7

Here’s another Puzzler from Car Talk (https://www.cartalk.com/puzzler/browse):
(((Car Talk)))

[quote]
____
This was sent in by a fellow named Dan O’Leary. He came upon a common one-syllable, five-letter word recently that has the following unique property. When you remove the first letter, the remaining letters form a homophone of the original word, that is a word that sounds exactly the same. Replace the first letter, that is, put it back and remove the second letter and the result is yet another homophone of the original word. And the question is, what’s the word?

Now I’m going to give you an example that doesn’t work. Let’s look at the five-letter word, ‘wrack.’ W-R-A-C-K, you know like to ‘wrack with pain.’ If I remove the first letter, I am left with a four-letter word, ’R-A-C-K.’ As in, ‘Holy cow, did you see the rack on that buck! It must have been a nine-pointer!’ It’s a perfect homophone. If you put the ‘w’ back, and remove the ‘r,’ instead, you’re left with the word, ‘wack,’ which is a real word, it’s just not a homophone of the other two words.

But there is, however, at least one word that Dan and we know of, which will yield two homophones if you remove either of the first two letters to make two, new four-letter words. The question is, what’s the word?
____

You can use the dictionary from <<ex11-1>> to check whether a string is in the word array.

[TIP]
====
To check whether two words are homophones, you can use the CMU Pronouncing Dictionary. You can download it from http://www.speech.cs.cmu.edu/cgi-bin/cmudict.
====

Write a program that lists all the words that solve the Puzzler.
